//$(document).ready(function() {
var model =
{
//    canvas: document.getElementById("fx-canvas"),
//    get canvas() { return document.getElementById("fx-canvas"); },
/////////    cx: this.canvas.getContext("2d"),
//    get cx() { return this.canvas.getContext("2d"); },
//properties:
    get x() { return this.unpx(this.canvas.style.left); },
    set x(newx) { this.canvas.style.left = this.px(newx); },
    get y() { return this.unpx(this.canvas.style.top); },
    set y(newy) { this.canvas.style.top = this.px(newy); },
    get w() { return this.unpx(this.canvas.style.width) / this.m_scale; },
    set w(neww) { console.log("new w", this.canvas.style.width = this.px(neww * this.m_scale)); },
    get h() { return this.unpx(this.canvas.style.height) / this.m_scale; },
    set h(newh) { console.log("new h", this.canvas.style.height = this.px(newh * this.m_scale)); },
    m_scale: 1.0,
    get scale() { return this.m_scale; },
    set scale(newsc)
    {
//        this.w *= newsc / this.m_scale;
//        this.h *= newsc / this.m_scale;
        var save = {w: this.w, h: this.h};
        this.m_scale = newsc;
        this.w = save.w; this.h = save.h;
        this.cx.scale(newsc, newsc);
        console.log("new scale %d, w %d, h %d", this.m_scale, this.w, this.h);
    },
//    get rect() { return {x: this.x, y: this.y, w: this.w, h: this.h}; },
    rect: function(x, y, w, h)
    {
        if ((arguments.length == 1) && (typeof x === 'object')) { h = x.h; w = x.w; y = x.y; x = x.x; } //unpack {x, y, w, h}
        if ((typeof x !== 'undefined') && (x !== null)) this.x = x;
        if ((typeof y !== 'undefined') && (y !== null)) this.y = y;
        if ((typeof w !== 'undefined') && (w !== null)) this.w = w;
        if ((typeof h !== 'undefined') && (h !== null)) this.h = h;
        return {x: this.x, y: this.y, w: this.w, h: this.h};
    },
//methods:
    init: function()
    {
        this.canvas = document.getElementById("fx-canvas");
        this.cx = this.canvas.getContext("2d"); //kludge: need to delay execution due to dependent member
//stuff to do every time:
//        this.cx.scale(10, 10);
    },
    validate: function()
    {
        if (!this.canvas) console.log("no canvas");
        else if (!this.canvas.getContext) console.log("no access to canvas");
        else console.log("canvas okay");
        if (!this.cx) console.log("no context");
        else if (!this.cx.clearRect) console.log("no access to context");
        else console.log("context okay");
        console.log("rect", this.rect());
    },
//drawing methods:
    clear: function(color)
    {
        this.cx.save(); //push state onto stack
        if ((typeof color !== 'undefined') && (color !== null)) this.cx.fillStyle = color; //"#000000"; //style when filling shapes
//    ctx.strokeStyle = "#000000"; //style for shapes' outlines
        this.cx[arguments.length? 'fillRect': 'clearRect'](0, 0, this.canvas.width, this.canvas.height); //color vs. transparent
        this.cx.restore(); //pop state
    },
    line: function(fromx, fromy, tox, toy, color, thickness)
    {
        if ((arguments.length == 1) && (typeof cols === 'object')) { thickness = cols.thickness; color = cols.color; rows = cols.rows; cols = cols.cols; } //unpack {dx, dy, color}
        this.cx.save(); //push state onto stack
        this.cx.beginPath();
        if ((typeof color !== 'undefined') && (color !== null)) this.cx.strokeStyle = color; //"#ddd"; //style for shapes' outlines
        if ((typeof thickness !== 'undefined') && (thickness !== null)) this.cx.lineWidth = thickness;
        this.cx.moveTo(fromx * this.m_scale, fromy * this.m_scale);
        this.cx.lineTo(tox * this.m_scale, toy * this.m_scale);
        this.cx.stroke();
        this.cx.restore(); //pop state
    },
    grid: function(cols, rows, color, thickness)
    {
        if ((arguments.length == 1) && (typeof cols === 'object')) { thickness = cols.thickness; color = cols.color; rows = cols.rows; cols = cols.cols; } //unpack {dx, dy, color}
        this.cx.save(); //push state onto stack
        this.cx.beginPath();
        if ((typeof color !== 'undefined') && (color !== null)) this.cx.strokeStyle = color; //"#ddd"; //style for shapes' outlines
        if ((typeof thickness !== 'undefined') && (thickness !== null)) this.cx.lineWidth = thickness;
        var dx = (this.w - 1) / (cols || 1), dy = (this.h - 1) / (rows || 1);
        for (var x = 0; x < this.w; x += dx)
        {
            this.cx.moveTo(x * this.m_scale, 0);
            this.cx.lineTo(x * this.m_scale, this.h * this.m_scale);
        }
        for (var y = 0; y < this.h; y += dx)
        {
            this.cx.moveTo(0, y * this.m_scale);
            this.cx.lineTo(this.w * this.m_scale, y * this.m_scale);
        }
        this.cx.stroke();
        this.cx.restore(); //pop state
    },
//helpers:
    px: function(n)
    {
        if (!n) return 0;
        return (('' + n).indexOf('px') == -1)? n + 'px': n;
    },
    unpx: function(str)
    {
        if (!str) return 0;
        return 1 * ('' + str).replace(/px$/, '');
    },
};
model.init();
console.log("canvas", model.canvas);
console.log("ctx", model.cx);
model.validate();

/*
model.resize = function(w, h)
{
//    this.canvas.width = ('' + w).replace(/px$/, '');
//    this.canvas.height = ('' + h).replace(/px$/, '');
    this.canvas.style.position = 'absolute';
    if ((typeof w !== 'undefined') && (w !== null)) this.canvas.style.width = this.px(w);
    if ((typeof h !== 'undefined') && (h !== null)) this.canvas.style.height = this.px(h);
}
model.moveto = function(x, y)
{
    this.canvas.style.position = 'absolute';
    if ((typeof x !== 'undefined') && (x !== null)) this.canvas.style.left = this.px(x);
    if ((typeof y !== 'undefined') && (y !== null)) this.canvas.style.top = this.px(y);
}
*/

