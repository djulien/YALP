<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body
      {
        margin: 0px;
        padding: 0px;
        background-color: #555;
      }
      #tooltip
      {
        position: absolute;
        bottom: 32px;
        left: 4px;
        color: #fff;
      }
      #myGrid
      {
        z-index: 99;
      }
      #myCanvas
      {
        z-index: 0;
      }
    </style>
    <xscript src="../tests/e4hw.js" type="text/javascript" charset="utf-8"></xscript>
    <xscript src="../tests/easter4.js" type="text/javascript" charset="utf-8"></xscript>
    <script>
        var module = {exports: {}};
    </script>
    <script src="../node_modules/pnglib/lib/pnglib.js" type="text/javascript" charset="utf-8"></script>
    <script>
        var pnglib = module.exports; //require('pnglib');
        function elapsat() { return '@' + elapsed(); }
        function elapsed()
        {
            if (typeof elapsed.started == 'undefined') elapsed.started = Date.now();
            return Date.now() - elapsed.started;
        }

function readFile(filepath){
  return function(callback){
    fs.readFile(filepath, callback);
  }
}

//        function* delay() { yield; }
        var dom_loaded = false;
        window.addEventListener('load', function(evt) { console.log("DOM loaded", elapsat()); dom_loaded = true; });
        function wait4dom()
        {
//            run(function* inner() { yield [window.addEventListener, 'load']; }); //, function() { newval(); });
            return /*yield*/ function(cb) //caller will pause until DOM loaded
            {
                console.log("wait for DOM load ...", dom_loaded, elapsat());
                if (dom_loaded)
                {
                    console.log("... DOM loaded", elapsat());
                    cb();
                }
                else window.addEventListener('load', function(evt) { cb(); });
            }
        }

        function wait4img(img, path)
        {
            return /*yield*/ function(cb) //caller will pause until image loaded
            {
                console.log("wait for img load ...", elapsat());
                img.onload = function(evt)
                {
                    console.log("... img loaded", elapsat());
                    cb();
                };
                img.src = path;
            }
        }

//        function ex_wait(msec)
//        {
//            return function (callback) { setTimeout(callback, ms); };
//        }
        function wait(msec)
        {
            var wakeat = Date.now() + msec;
            return /*yield*/ function wake(cb) //caller pause until time elapsed
            {
                var premature = wakeat - Date.now();
                if (premature <= 0)
                {
                    console.log("... waited " + msec + " msec, overdue ", -premature, elapsat());
                    cb();
                }
                else setTimeout(wake, premature, cb);
            }
            console.log("wait " + msec + " msec ...", elapsat());
            wake();
//            run(function* inner() { yield [setTimeout, msec]; });
//            run(delay); //suspends until timeout is over
        }

        function mouse(canvas)
        {
            var trail = '';
            var tooltip = document.getElementById('tooltip');
            canvas.addEventListener('mousedown', function(evt)
            {
                var x = Math.floor((evt.pageX - 10) / 20), y = Math.floor((evt.pageY - 10) / 20);
                if ((x < 0) || (x >= 48) || (y < 0) || (y >= 16)) return;
                var buf = '(' + x + ', ' + y + ')';
                trail += ', ' + x + ',' + y;
                console.log("MOUSE", evt, buf);
                tooltip.innerHTML = trail.substr(2);
            }, false);
        }

        function* main()
        {//try{
            console.log("start", elapsat());
            yield wait4dom();
            var canvas = document.getElementById('myCanvas');
            var ctx = canvas.getContext('2d');
            grid(ctx, {x: 10, y: 10, w: 48 * 20, h: 16 * 20, dx: 20, dy: 20}, '#aaa');
//            var img = new Image();
//            yield wait4img(img, 'file:///home/dj/Documents/ESOL-fog/graphics/Easter/Easter-He-Is-Risen48x16.png');
//            drawimg(img, ctx);
            function img(which)
            {
                var img = USflag;
                switch (which & 3)
                {
                    case 1: img = USflag_up; break;
                    case 3: img = USflag_down; break;
                }
                img.draw(ctx, {x: 10, y: 10, /*w: 100, h: 100,*/ scale: 20, clear: true}, true);
            }
            mouse(canvas);
            for (var i = 0; i <= 10; ++i)
            {
                img(i);
                yield wait(500);
//                ctx.fillStyle = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff', '#fff'][i % 7];
//                ctx.fillRect(100 + i * 5, 100 + i * 5, 20, 20); //CAUTION: graphics context is top-to-bottom; trying to turn it right side up here
                console.log("i = " + i);
            }
            console.log("done", elapsat());
        }//catch(exc){ console.error(exc.message); }}

/*
        function drawimg(img, ctx)
        {
            var dest = {x: 10, y: 10, w: 100, h: 100}, scale = 20;
            dest.w = img.width * scale; dest.dx = scale;
            dest.h = img.height * scale; dest.dy = scale;
//see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
            ctx.imageSmoothingEnabled = false; //see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled
            ctx.drawImage(img, dest.x, dest.y, dest.w, dest.h); //origin = top left
            console.log("img %d x %d => %d x %d", img.width, img.height, dest.w, dest.h);
//            grid(ctx, dest, '#aaa');
        }
*/

        function grid(ctx, img, color)
        {
          ctx.save();
          ctx.strokeStyle = color; //"rgb(200, 100, 50)";
          var w = img.w; //ctx.canvas.height;
          var h = img.h; //ctx.canvas.width;
          console.log("grid (0 + %d, 0 + %d)..(%d, %d) by (%d, %d)", img.x, img.y, img.w, img.h, img.dx, img.dy); //this.canvas.width, dx);
          for (var x = 0; x <= img.w; x += img.dx)
          {
            ctx.moveTo(x + img.x, 0 + img.y);
            ctx.lineTo(x + img.x, h + img.y);
          }
          for (var y = 0; y <= img.h; y += img.dy)
          {
            ctx.moveTo(0 + img.x, y + img.y);
            ctx.lineTo(w + img.x, y + img.y);
          }
          ctx.stroke();
          ctx.restore();
        }

function xpm(data)
{
    if (!(this instanceof xpm)) return new xpm.apply(xpm, [null].concat(Array.from(arguments)))();
    var ofs = 0;
//    this.pixels = [];
    var parts = data[ofs++].match(/^\s*(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s*$/);
    if (!parts || (parts.length != 4+1)) throw "bad xpm line 1: " + data[--ofs];
    var w = parseInt(parts[1]), h = parseInt(parts[2]), numcolors = parseInt(parts[3]), chpp = parseInt(parts[4]);
    console.log("w %d, h %d, #c %d, chpp %d", w, h, numcolors, chpp);
//    if (chpp != 1) throw "xpm not implemented: " + chpp + " char/pixel";
    this.palette = {};
    var parse = new RegExp("^(.{" + chpp + "})\\s+c\\s+([^ ]+)\s*$", 'i');
    for (var i = 0; i < numcolors; ++i)
    {
        parts = data[ofs++].match(parse);
        if (!parts || (parts.length != 2+1)) throw "xpm bad color[" + i + "/" + numcolors + "]: " + data[--ofs];
        this.palette[parts[1]] = this.getcolor(parts[2]);
    }
    var buf = ''; for (var i in this.palette) buf += ', "' + i + '": 0x' + (this.palette[i] >>> 0).toString(16);
    console.log("xpm got %d colors:", numcolors, this.palette, '{' + buf.substr(2) + '}');
    Object.defineProperties(this,
    {
        width: { get() { return this.colorinx[0].length; }, enumerable: true, },
        height: { get() { return this.colorinx.length; }, enumerable: true, },
    });
//    this.image = new Image(w, h);
//    var img = this.image.getImageData(0, 0, w, h); //kludge: this is needed in order to force image.data to be created
//    this.abgr = new Uint32Array(w * h); //img.data);
//console.log("img data len", /*img.data.length,*/ this.abgr.length, this.width, this.height);
    this.colorinx = [];
    for (var y = 0; y < h; ++y, ++ofs)
    {
        if (data[ofs].length != w * chpp) throw "xpm bad row[" + y + "]: len " + data[ofs].length + " (expected " + (w * chpp) + ")";
//        var row = this.pixels[y] = [];
//        this.colorinx.push(data[ofs]); //save color inx so palette can be changed independently
        var row = this.colorinx[y] = [];
        for (var x = 0; x < w; ++x)
        {
            var code = data[ofs].substr(chpp * x, chpp);
            if (!(code in this.palette)) throw "xpm: unknown color code '" + code + "' @(" + x + ", " + y + ")";
//            this.abgr[y * w + x] = this.palette[this.colorinx[y][x]]; //actual color; ABGR expected; use A for transparency
            row.push(code); //indexed colors
//            row.push(this.colors[data[ofs].charCodeAt(x)]); //actual color
//2x			row.push(colors[data[ofs].charCodeAt(x)]);
        }
    }
//    img.data.set(newdata); //putImageData(img, 0, 0, w, h); //new Uint8ClampedArray(buf);
//    setimgdata(this.image, newdata)
    if (ofs < data.length) throw "xpm: junk at end " + (data.length - ofs);
//    return this.pixels;
}

//bmp: http://mrcoles.com/media/js/bitmap.js
xpm.prototype.imgdata = function imgdata()
{
    var png = new pnglib(this.width, this.height, 8);
    var bkg = png.color(0, 0, 0, 0);  //first color = bkg RGBA
    for (var y = 0; y < this.height; ++y)
        for (var x = 0; x < this.width; ++x)
        {
            var color = this.palette[this.colorinx[y][x]]; // * this.width + x]];
//            console.log("(" + x + ", " + y + ") isa " + typeof color);
            if (typeof color != 'number') color = bkg;
            else color = png.color((color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff, color >> 24);
            png.buffer[png.index(x, y)] = color;
        }
//    var svload = img.onload;
//    img.onload = function()
//    {
//        context.drawImage(this, 0, 0, canvas.width, canvas.height);
//        img.onload = svload;
//    }
//  context.drawImage(this, 0, 0, canvas.width, canvas.height);
//    img.src = "data:image/gif;base64,R0lGODlhDwAPAKECAAAAzMzM/////wAAACwAAAAADwAPAAACIISPeQHsrZ5ModrLlN48CXF8m2iQ3YmmKqVlRtW4MLwWACH+H09wdGltaXplZCBieSBVbGVhZCBTbWFydFNhdmVyIQAAOw==";
    return "data:image/png;base64," + png.getBase64();
}

//xpm ARGB => image data ABGR
xpm.prototype.argb2abgr = function argb2abgr(argb)
{
    argb >>>= 0;
//    if ((argb & 0xffffff) && !(argb & 0xff000000)) argb |= 0xff000000; //caller probably meant opaque
    return ((argb & 0xff00ff00) | ((argb >> 16) & 0xff) | ((argb << 16) & 0xff0000)) >>> 0; //force to uint32
}

xpm.prototype.swab = function swab(val32)
{
    var swapped = this.swab_inner(val32);
    console.log("swap: from", (val32 >>> 0).toString(16), "to", (swapped >>> 0).toString(16));
    return swapped;
}

xpm.prototype.swab_inner = function swab(val32)
{
    val32 >>>= 0;
    if (typeof swab.needswap == 'undefined')
    {
        var buf = new ArrayBuffer(4);
        var buf32 = new Uint32Array(buf);
        var buf8 = new Uint8ClampedArray(buf);
        buf32[0] = 0x12345678;
        swab.needswap = (buf8[0] != 0x12) || (buf8[3] != 0x78);
        console.log("need swap?", swab.needswap, (buf8[0] + 0).toString(16), (buf8[1] + 0).toString(16), (buf8[2] + 0).toString(16), (buf8[3] + 0).toString(16));
    }
    return swab.needswap? (val32 >> 24) | ((val32 >> 8) & 0xff00) | ((val32 << 8) & 0xff0000) | (val32 << 24): val32;
}

xpm.prototype.setpal = function setpal(newpal)
{
//    if (newpal.length != this.palette.length) throw "xpm setpal: wrong #colors (got " + newpal.length + ", expected " + this.palette.length + ")";
//    this.colors = {};
    for (var c in newpal)
    {
        if (!(c in this.palette)) throw "xpm: unknown color code '" + c + "' = " + newpal[c];
        this.palette[c] = this.getcolor(newpal[c]);
    }
    this.img = null; //need to regenerate image data
//redraw image with new colors:
//    this.abgr = new Uint32Array(this.width * this.height); //img.data);
//    for (var y = 0; y < this.height; ++y)
//        for (var x = 0; x < this.width; ++x)
//            newdata[y * this.width + x] = this.palette[this.colorinx[y][x]]; //actual color; ABGR expected; use A for transparency
//    this.image.data.set(newdata); //putImageData(img, 0, 0, w, h); //new Uint8ClampedArray(buf);
    return this; //fluent
}

xpm.prototype.getcolor = function getcolor(color)
{
    if (typeof color == 'number') return color >>> 0;
    color += ''; //convert to string
    if (!color.match(/^(none|#[0-9a-f]{6})$/i)) throw "xpm bad color: " + color;
//    return (color[0] == '#')? /*this.argb2abgr*/(/*this.swab*/(parseInt(color.substr(1), 16)) | 0xff000000): 0; //alpha 0 => transparent (none)
    return (color[0] == '#')? (parseInt(color.substr(1), 16) >>> 0) | 0xff000000: 0; //alpha 0 => transparent (none)
}

//other ways: http://stackoverflow.com/questions/7242006/html5-copy-a-canvas-to-image-and-back
//or https://hacks.mozilla.org/2011/12/faster-canvas-pixel-manipulation-with-typed-arrays/
//   http://jsfiddle.net/andrewjbaker/Fnx2w/
xpm.prototype.draw = function draw(ctx, dest, force)
{
    if (!dest) dest = {}; //dest = {x: 10, y: 10, w: 100, h: 100, scale: 20};
    var fade = (dest.fade || 255) / 255; //TODO
    var dx = dest.scale || 10, w = this.width * dx, x = dest.x || 10;
    var dy = dest.scale || 10, h = this.height * dy, y = dest.y || 10;
//see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
    ctx.imageSmoothingEnabled = false; //see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled
//    ctx.drawImage(this.image, dest.x || 10, dest.y || 10, w, h); //origin = top left
    if (!this.img) //gen img data
    {
        force = true;
        this.img = new Image(this.width, this.height);
        this.img.onload = function() //finish async
        {
            console.log("async img draw", this.img.width, this.img.height);
            ctx.drawImage(this.img, x, y, w, h); //this.width, this.height);
        }.bind(this);
        console.log("set up async draw");
    }
    if (force)
    {
        if (dest.clear) ctx.clearRect(x, y, w, h);
        this.img.src = this.imgdata();
        console.log("img src", this.img.src);
    }
//    else { console.log("sync draw"); ctx.drawImage(this.img, dest.x || 10, dest.y || 10, w, h); } //this.width, this.height);
//    var svload = img.onload;
//    img.onload = function()
//    {
//        context.drawImage(this, 0, 0, canvas.width, canvas.height);
//        img.onload = svload;
//    }
//  context.drawImage(this, 0, 0, canvas.width, canvas.height);

/*
//    ctx.drawImage(img, dest.x || 10, dest.y || 10, w, h); //origin = top left
    var img = ctx.getImageData(dest.x || 0, dest.y || 0, w, h);
console.log("img data w h", w, h, dest.x, dest.y, img.data.length);
//    var buf = ArrayBuffer.transfer(img.data, img.data.length);
    var newdata = new Uint32Array(img.data);
console.log("img data len", img.data.length, newdata.length, this.width, this.height);
    for (var y = 0; y < this.height; ++y)
        for (var x = 0; x < this.width; ++x)
            newdata[y * this.width + x] = this.colors[this.pixels[y][x]]; //actual color
    img.data.set(newdata); //new Uint8ClampedArray(buf));
    ctx.putImageData(img, dest.x || 0, dest.y || 0); //, w, h);
*/
    console.log("img %d x %d => %d x %d", this.width, this.height, w, h);
//            grid(ctx, dest, '#aaa');
    return this; //fluent
}

xpm.prototype.resize = function resize(w, h)
{
//NOTE: use distint arrays on each row to allow pixels to be set differently later
    if (this.height > h) this.colorinx.splice(h, this.height - h); //shrink
    while (this.height < h) this.colorinx.push(new Array(w)); //grow
    var wadjust = w - this.width; //CAUTION: need to save this before altering first row
    for (var y = 0; y < this.height; ++y)
    {
        if (wadjust < 0) this.colorinx[y].splice(w, -wadjust); //shrink
        if (wadjust > 0) this.colorinx[y].splice(w - wadjust, new Array(wadjust)); //grow
    }
    this.img = null; //need to regenerate image data
    return this; //fluent
}

Array.prototype.scroll = function scroll(ofs, newvals)
{
    if (!ofs) return;
    var svlen = this.length;
    var removed = (ofs < 0)? this.splice(0, -ofs): this.splice(this.length - ofs, ofs);
    console.log("array.scroll: removed %d..+%d: %d", (ofs < 0)? 0: svlen - ofs, (ofs < 0)? -ofs: ofs, removed.length);
    if (arguments.length > 1) removed.forEach(newvals); //function(y, row) { row.forEach(function(x) { row[x] = newval; }); });
    if (arguments.length > 1) console.log("array.scroll: init to %j", newvals);
    svlen = this.length;
//wrong    this.splice((ofs < 0)? this.length: 0, 0, removed);
    removed.splice(0, 0, (ofs < 0)? this.length: 0, 0);
    this.splice.apply(this, removed);
    console.log("array.scroll: added %d..+%d: %d", (ofs < 0)? svlen: 0, 0, removed.length);
    return removed;
}

xpm.prototype.scroll = function scroll(xofs, yofs)
{
    this.colorinx.scroll(yofs, function(row) { row.fill(0); });
    for (var y = 0; y < this.height; ++y)
        this.colorinx[y].scroll(xofs, function(val, inx, ary) { ary[inx] = 0; });
    this.img = null; //need to regenerate image data
    return this; //fluent
}

xpm.prototype.scroll1col = function scroll(x, yofs)
{
    if ((x >= 0) && (x < this.width))
    {
        if (yofs < 0)
            for (var y = 0; y < this.height; ++y)
                this.colorinx[y][x] = (y < this.height + yofs)? this.colorinx[y - yofs][x]: 0;
        if (yofs > 0)
            for (var y = this.height - 1; y >= 0; --y)
                this.colorinx[y][x] = (y >= yofs)? this.colorinx[y - yofs][x]: 0;
    }
    this.img = null; //need to regenerate image data
    return this; //fluent
}

xpm.prototype.clone = function clone()
{
    var retval = new xpm(["1 1 1 1", "  c #000000", " "]); //1-pixel dummy image
    retval.palette = {};
    for (var color in this.palette)
        retval.palette[color] = this.palette[color];
    retval.colorinx = [];
    for (var y = 0; y < this.height; ++y)
        retval.colorinx.push(this.colorinx[y].slice());
    this.img = null; //need to regenerate image data
    return retval;
}


/* XPM */
const USflag = new xpm(
[
"24 13 4 2",
"  	c #000000",
". 	c #FF0000",
"# 	c #0000FF",
"& 	c #FFFFFF",
"# # # # # # # # # . . . . . . . . . . . . . . . ",
"# & # & # & # & # & & & & & & & & & & & & & & & ",
"# # & # & # & # # . . . . . . . . . . . . . . . ",
"# & # & # & # & # & & & & & & & & & & & & & & & ",
"# # & # & # & # # . . . . . . . . . . . . . . . ",
"# & # & # & # & # & & & & & & & & & & & & & & & ",
"# # # # # # # # # . . . . . . . . . . . . . . . ",
"& & & & & & & & & & & & & & & & & & & & & & & & ",
". . . . . . . . . . . . . . . . . . . . . . . . ",
"& & & & & & & & & & & & & & & & & & & & & & & & ",
". . . . . . . . . . . . . . . . . . . . . . . . ",
"& & & & & & & & & & & & & & & & & & & & & & & & ",
". . . . . . . . . . . . . . . . . . . . . . . . ",
]);

USflag.resize(USflag.width, USflag.height + 2);
USflag.scroll(0, +1);

const USflag_up = USflag.clone(), USflag_down = USflag.clone();
for (var x = 0; x < USflag.width; ++x)
{
    if (!(Math.floor(x / 4) & 1)) continue;
    USflag_up.scroll1col(x, -1);
    USflag_down.scroll1col(x, +1);
}


//http://tobyho.com/2013/06/16/what-are-generators/
        var fido = 0;
        function run(genfun)
        {
            var gen = genfun();
            // This is the async loop pattern
            function next(err, answer)
            {
                if (++fido > 20) { console.error("INF LOOP"); return; }
                if (err) return gen.throw(err);
                var res = gen.next(answer);
                if (!res.done) res.value(next);
      // if we are not at the end
      // we have an async request to
      // fulfill, we do this by calling
      // `value` as a function
      // and passing it a callback
      // that receives err, answer
      // for which we'll just use `next()`
            }
            next();
        }
        run(main);

        if (false)
        for (var it = main(), state = it.next(), max = 0; !state.done && (++max < 20); state.value(it.next)) //iterate thru generator
        {
            console.log("state", state, elapsat());
            if (typeof state.value !== 'function') throw "yielded !function: " + typeof state.value;
        }
//        function run(gen, args)
//        {
//            for (var msg of gen()) //.apply(null, arguments)) //iterate thru generator
//                console.log("dispatched", msg);
//        }
//        run(main);
//        main();
//        var it = main();
//        var msg = it.next();

/*
      Object.defineProperty(document, 'onload', //shim
      { set: function(newval)
        {
          console.log("set evt");
//see http://stackoverflow.com/questions/15580084/javascript-like-document-ready-for-modern-html5-browsers
          window.addEventListener('load' /-*'DOMContentLoaded'*-/, function() { newval(); });
        }
      });
      document.onload = function()
      {
        console.log("on load");
        var canvas = document.getElementById('myCanvas');
        var ctx = canvas.getContext('2d');
        ctx.grid = function(img, color)
        {
          ctx.save();
          ctx.strokeStyle = color; //"rgb(200, 100, 50)";
          console.log("grid (0 + %d, 0 + %d)..(%d, %d) by (%d, %d)", img.x, img.y, img.w, img.h, img.dx, img.dy); //this.canvas.width, dx);
          for (var x = 0; x <= img.w; x += img.dx)
          {
            ctx.moveTo(x + img.x, 0 + img.y);
            ctx.lineTo(x + img.x, this.canvas.height + img.y);
          }
          for (var y = 0; y <= img.h; y += img.dy)
          {
            ctx.moveTo(0 + img.x, y + img.y);
            ctx.lineTo(this.canvas.width + img.x, y + img.y);
          }
          ctx.stroke();
          ctx.restore();
        }
        ctx.imageSmoothingEnabled = false; //see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled
        var imageObj = new Image();
        imageObj.onload = function()
        {
	  var dest = {x: 10, y: 10, w: 100, h: 100}, scale = 20;
          dest.w = this.width * scale; dest.dx = scale;
          dest.h = this.height * scale; dest.dy = scale;
//see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
          ctx.drawImage(imageObj, dest.x, dest.y, dest.w, dest.h); //origin = top left
          console.log("img %d x %d => %d x %d", this.width, this.height, dest.w, dest.h);
          ctx.grid(dest, '#aaa');
        };
//        imageObj.src = 'http://www.html5canvastutorials.com/demos/assets/darth-vader.jpg';
        if (false) imageObj.src = 'file:///home/dj/Documents/ESOL-fog/graphics/Easter/Easter-He-Is-Risen48x16.png';
//        imageObj.src = 'file:///home/dj/Documents/ESOL-fog/graphics/Easter/Easter-Piskel.gif';
        seq(imageObj);
      }
*/
    </script>
  </head>
  <body>
    <canvas id="myCanvas" width="1000" height="600">CANVAS NOT SUPPORTED?</canvas>
    <canvas id="myGrid" width="1000" height="600">CANVAS NOT SUPPORTED?</canvas>
    <div id="tooltip"></div>
  </body>
</html>
